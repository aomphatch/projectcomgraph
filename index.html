<!DOCTYPE html>
<html>

<head>
    <title>Load GLB</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <script>
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        // ‡πÇ‡∏´‡∏•‡∏î EXR environment
        const exrLoader = new THREE.EXRLoader();
        exrLoader.load('https://aomphatch.github.io/comgraphproj/dikhololo_night_1k.exr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
        });

        // ‡∏Å‡∏•‡πâ‡∏≠‡∏á
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.2, 1000);
        camera.position.set(5.6, 0.6, 6.2);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // --- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ---
        const initialCameraPosition = camera.position.clone();
        const initialCameraTarget = controls.target.clone();

        // --- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á station1 ---
        let station2CameraPosition = null;
        let station2CameraTarget = null;

        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á station2
        let station3CameraPosition = null;
        let station3CameraTarget = null;

        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á station3
        let station4CameraPosition = null;
        let station4CameraTarget = null;


        // ‡πÅ‡∏™‡∏á
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        
        const pointLight = new THREE.PointLight(0xffdd00, 0.8, 8);  //(‡∏™‡∏µ, ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡πÅ‡∏™‡∏á, distance ‚Äì ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏á‡∏à‡∏∞‡∏°‡∏µ‡∏ú‡∏•)
        pointLight.position.set(1, 5, 12);
        pointLight.castShadow = true;
        scene.add(pointLight);
        const pointLightHelper = new THREE.PointLightHelper(pointLight, 1);   //‡∏ï‡∏±‡∏ß‡∏ä‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏•‡∏≠‡∏î‡πÑ‡∏ü
        scene.add(pointLightHelper);
        

        const gltfLoader = new THREE.GLTFLoader();
        //const arcade = 'https://aomphatch.github.io/comgraphproj/arcade.glb';
        const shop = 'https://aomphatch.github.io/projectcomgraph/shop.glb';
        const tomb = 'https://aomphatch.github.io/projectcomgraph/tomb.glb';
        const streetlight = 'https://aomphatch.github.io/projectcomgraph/streetlight.glb';
        const convex = 'https://aomphatch.github.io/projectcomgraph/convex.glb';
        const busstop = 'https://aomphatch.github.io/projectcomgraph/busstop.glb';
        const vespa = 'https://aomphatch.github.io/projectcomgraph/vespa.glb';
        //const busstopboard = 'https://aomphatch.github.io/projectcomgraph/busstopboard.glb';
        const hotel = 'https://aomphatch.github.io/projectcomgraph/hotel.glb';
        const name = 'https://aomphatch.github.io/projectcomgraph/name.glb';
        const street = 'https://aomphatch.github.io/projectcomgraph/street.glb';
        const toheavenshop = 'https://aomphatch.github.io/projectcomgraph/toheavenshop.glb';
        const bin = 'https://aomphatch.github.io/projectcomgraph/bin.glb';
        const tree = 'https://aomphatch.github.io/projectcomgraph/tree.glb';
        
        const sign = 'https://aomphatch.github.io/projectcomgraph/sign.glb'; 
        const firstchoice = 'https://aomphatch.github.io/projectcomgraph/firstchoice.glb';
        const secondchoice = 'https://aomphatch.github.io/projectcomgraph/secondchoice.glb';
        const thirdchoice = 'https://aomphatch.github.io/projectcomgraph/thirdchoice.glb';

        const station1 = 'https://aomphatch.github.io/projectcomgraph/station1.glb';
        const station2 = 'https://aomphatch.github.io/projectcomgraph/station2.glb';
        const station3 = 'https://aomphatch.github.io/projectcomgraph/station3.glb';
        const station4 = 'https://aomphatch.github.io/projectcomgraph/station4.glb';

        const backfromname = 'https://aomphatch.github.io/projectcomgraph/backfromname.glb';
        const nextfromstation1 = 'https://aomphatch.github.io/projectcomgraph/nextfromstation1.glb';
        const backfromstation1 = 'https://aomphatch.github.io/projectcomgraph/backfromstation1.glb';
        const nextfromstation2 = 'https://aomphatch.github.io/projectcomgraph/nextfromstation2.glb';
        const backfromstation2 = 'https://aomphatch.github.io/projectcomgraph/backfromstation2.glb';
        const nextfromstation3 = 'https://aomphatch.github.io/projectcomgraph/nextfromstation3.glb';
        const backfromstation3 = 'https://aomphatch.github.io/projectcomgraph/backfromstation3.glb';
        const backfromstation4 = 'https://aomphatch.github.io/projectcomgraph/backfromstation4.glb';



        // ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
        let firstchoiceModel = null;
        let secondchoiceModel = null;
        let nameModel = null;
        let backfromnameModel = null;
        let station1Model = null;
        let nextfromstation1Model = null;
        let backfromstation1Model = null;
        let station2Model = null;
        let nextfromstation2Model = null;
        let backfromstation2Model = null;
        let station3Model = null;
        let nextfromstation3Model = null;
        let backfromstation3Model = null;
        let station4Model = null;
        let backfromstation4Model = null;

        /*Shop Loader*/
        gltfLoader.load(
           shop,
            (gltf) => {
                const shopModel = gltf.scene;

                shopModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(shopModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*ToheavenShop Loader*/
        gltfLoader.load(
           toheavenshop,
            (gltf) => {
                const toheavenshopModel = gltf.scene;

                toheavenshopModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(toheavenshopModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Tomb Loader*/
        gltfLoader.load(
           tomb,
            (gltf) => {
                const tombModel = gltf.scene;

                tombModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // üîß ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ roughness / metalness ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
                        child.material.roughness = 1.0;   // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 = ‡∏°‡∏±‡∏ô‡∏ß‡∏≤‡∏ß ‡∏°‡∏≤‡∏Å ‚Üí 1 = ‡∏î‡πâ‡∏≤‡∏ô
                        //child.material.metalness = 0.2;   // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 = ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏•‡∏´‡∏∞ ‚Üí 1 = ‡πÇ‡∏•‡∏´‡∏∞
                    }
                });

                scene.add(tombModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*StreetLight Loader*/
        gltfLoader.load(
           streetlight,
            (gltf) => {
                const streetlightModel = gltf.scene;

                streetlightModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(streetlightModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Convex Loader*/
        gltfLoader.load(
           convex,
            (gltf) => {
                const convexModel = gltf.scene;

                convexModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        child.material.metalness = 0.9;   // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 = ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏•‡∏´‡∏∞ ‚Üí 1 = ‡πÇ‡∏•‡∏´‡∏∞
                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(convexModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Busstop Loader*/
        gltfLoader.load(
           busstop,
            (gltf) => {
                const busstopModel = gltf.scene;

                busstopModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(busstopModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Hotel Loader*/
        gltfLoader.load(
           hotel,
            (gltf) => {
                const hotelModel = gltf.scene;

                hotelModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(hotelModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Name Loader*/
        gltfLoader.load(
           name,
            (gltf) => {
                nameModel = gltf.scene;

                nameModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(nameModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Street Loader*/
        gltfLoader.load(
           street,
            (gltf) => {
                const streetModel = gltf.scene;

               streetModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(streetModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Vespa Loader*/
        gltfLoader.load(
           vespa,
            (gltf) => {
                const vespaModel = gltf.scene;

                vespaModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // üîß ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ roughness / metalness ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
                        child.material.roughness = 0.2;   // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 = ‡∏°‡∏±‡∏ô‡∏ß‡∏≤‡∏ß ‡∏°‡∏≤‡∏Å ‚Üí 1 = ‡∏î‡πâ‡∏≤‡∏ô
                        child.material.metalness = 0.5;   // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 = ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏•‡∏´‡∏∞ ‚Üí 1 = ‡πÇ‡∏•‡∏´‡∏∞
                    }
                });     

                scene.add(vespaModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Bin Loader*/
        gltfLoader.load(
           bin,
            (gltf) => {
                const binModel = gltf.scene;

                binModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                    }
                });     

                scene.add(binModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Tree Loader*/
        gltfLoader.load(
           tree,
            (gltf) => {
                const treeModel = gltf.scene;

                treeModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(treeModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Sign Loader*/
        gltfLoader.load(
           sign,
            (gltf) => {
                const signModel = gltf.scene;

                signModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(signModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );  

        /*Firstchoice Loader*/
        gltfLoader.load(
           firstchoice,
            (gltf) => {
               firstchoiceModel = gltf.scene;

               firstchoiceModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(firstchoiceModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Secondchoice Loader*/
        gltfLoader.load(
           secondchoice,
            (gltf) => {
                secondchoiceModel = gltf.scene;

               secondchoiceModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(secondchoiceModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Thirdchoice Loader*/
        gltfLoader.load(
           thirdchoice,
            (gltf) => {
                const thirdchoiceModel = gltf.scene;

               thirdchoiceModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(thirdchoiceModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 
        
        /*Backfromname Loader*/
        gltfLoader.load(
           backfromname,
            (gltf) => {
                backfromnameModel = gltf.scene;

               backfromnameModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(backfromnameModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Station1 Loader*/
        gltfLoader.load(
           station1,
            (gltf) => {
                station1Model = gltf.scene;

                station1Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(station1Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

         /*Backfromstation1 Loader*/
        gltfLoader.load(
           backfromstation1,
            (gltf) => {
                backfromstation1Model = gltf.scene;

               backfromstation1Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(backfromstation1Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Nextfromstation1 Loader*/
        gltfLoader.load(
           nextfromstation1,
            (gltf) => {
                nextfromstation1Model = gltf.scene;

               nextfromstation1Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(nextfromstation1Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Station2 Loader*/
        gltfLoader.load(
           station2,
            (gltf) => {
                station2Model = gltf.scene;

                station2Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(station2Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

         /*Backfromstation2 Loader*/
        gltfLoader.load(
           backfromstation2,
            (gltf) => {
                backfromstation2Model = gltf.scene;

               backfromstation2Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(backfromstation2Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Nextfromstation2 Loader*/
        gltfLoader.load(
           nextfromstation2,
            (gltf) => {
                nextfromstation2Model = gltf.scene;

               nextfromstation2Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(nextfromstation2Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Station3 Loader*/
        gltfLoader.load(
           station3,
            (gltf) => {
                station3Model = gltf.scene;

                station3Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(station3Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

         /*Backfromstation3 Loader*/
        gltfLoader.load(
           backfromstation3,
            (gltf) => {
                backfromstation3Model = gltf.scene;

               backfromstation3Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(backfromstation3Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Nextfromstation3 Loader*/
        gltfLoader.load(
           nextfromstation3,
            (gltf) => {
                nextfromstation3Model = gltf.scene;

               nextfromstation3Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(nextfromstation3Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 

        /*Station4 Loader*/
        gltfLoader.load(
           station4,
            (gltf) => {
                station4Model = gltf.scene;

                station4Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô Mesh + id
                        }
                });

                scene.add(station4Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Backfromstation4 Loader*/
        gltfLoader.load(
           backfromstation4,
            (gltf) => {
                backfromstation4Model = gltf.scene;

               backfromstation4Model.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });     

                scene.add(backfromstation4Model);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        ); 


        // Raycaster ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            if (!secondchoiceModel || !nameModel || !backfromnameModel || !firstchoiceModel || !station1Model || !backfromstation1Model || !nextfromstation1Model || !station2Model || !backfromstation2Model || !nextfromstation2Model || !station3Model || !backfromstation3Model || !nextfromstation3Model || !station4Model || !backfromstation4Model ) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å firstchoice: ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station1 ---
            const intersectsFirst = raycaster.intersectObjects(firstchoiceModel.children, true);
            if (intersectsFirst.length > 0) {
                // ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á firstchoice
                station1CameraPosition = camera.position.clone();
                station1CameraTarget = controls.target.clone();

                // ‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station1
                const box = new THREE.Box3().setFromObject(station1Model);
                const center = box.getCenter(new THREE.Vector3());
                camera.position.set(center.x, center.y + 0.2, center.z + 1); // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å backfromstation1: ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á firstchoice ---
            const intersectsBackStation1 = raycaster.intersectObjects(backfromstation1Model.children, true);
            if (intersectsBackStation1.length > 0 && station1CameraPosition && station1CameraTarget) {
                camera.position.copy(station1CameraPosition);
                controls.target.copy(station1CameraTarget);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å nextfromstation1: ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á station1 ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station2 ---
            const intersectsNextStation1 = raycaster.intersectObjects(nextfromstation1Model.children, true);
            if (intersectsNextStation1.length > 0) {
                // ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station1
                station2CameraPosition = camera.position.clone();
                station2CameraTarget = controls.target.clone();

                // ‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station2
                const box = new THREE.Box3().setFromObject(station2Model);
                const center = box.getCenter(new THREE.Vector3());
                camera.position.set(center.x+0.05, center.y + 0.3, center.z - 1.25); // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å backfromstation2: ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station1 ---
            const intersectsBackStation2 = raycaster.intersectObjects(backfromstation2Model.children, true);
            if (intersectsBackStation2.length > 0 && station2CameraPosition && station2CameraTarget) {
                camera.position.copy(station2CameraPosition);
                controls.target.copy(station2CameraTarget);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å nextfromstation2: ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á station2 ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station3 ---
            const intersectsNextStation2 = raycaster.intersectObjects(nextfromstation2Model.children, true);
            if (intersectsNextStation2.length > 0) {
                // ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station2
                station3CameraPosition = camera.position.clone();
                station3CameraTarget = controls.target.clone();

                // ‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station3
                const box = new THREE.Box3().setFromObject(station3Model);
                const center = box.getCenter(new THREE.Vector3());
                camera.position.set(center.x, center.y + 0.05, center.z + 1); // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å backfromstation3: ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station2 ---
            const intersectsBackStation3 = raycaster.intersectObjects(backfromstation3Model.children, true);
            if (intersectsBackStation3.length > 0 && station3CameraPosition && station3CameraTarget) {
                camera.position.copy(station3CameraPosition);
                controls.target.copy(station3CameraTarget);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å nextfromstation3: ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á station3 ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station4 ---
            const intersectsNextStation3 = raycaster.intersectObjects(nextfromstation3Model.children, true);
            if (intersectsNextStation3.length > 0) {
                // ‡∏à‡∏≥‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station3
                station4CameraPosition = camera.position.clone();
                station4CameraTarget = controls.target.clone();

                // ‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏õ station4
                const box = new THREE.Box3().setFromObject(station4Model);
                const center = box.getCenter(new THREE.Vector3());
                camera.position.set(center.x+0.95, center.y + 0.15, center.z - 0.15); // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                return;
            }

            // --- ‡∏Ñ‡∏•‡∏¥‡∏Å backfromstation4: ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á station3 ---
            const intersectsBackStation4 = raycaster.intersectObjects(backfromstation4Model.children, true);
            if (intersectsBackStation4.length > 0 && station4CameraPosition && station4CameraTarget) {
                camera.position.copy(station4CameraPosition);
                controls.target.copy(station4CameraTarget);
                controls.update();
                return;
            }

            // ...‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö secondchoice, backfromname...
            const intersectsSecond = raycaster.intersectObjects(secondchoiceModel.children, true);
            if (intersectsSecond.length > 0) {
                const box = new THREE.Box3().setFromObject(nameModel);
                const center = box.getCenter(new THREE.Vector3());
                camera.position.set(center.x, center.y + 0.2, center.z + 1.5);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                return;
            }

            const intersectsBack = raycaster.intersectObjects(backfromnameModel.children, true);
            if (intersectsBack.length > 0) {
                camera.position.copy(initialCameraPosition);
                controls.target.copy(initialCameraTarget);
                controls.update();
                return;
            }
        });


        // ‡∏û‡∏∑‡πâ‡∏ô
        const floorTex = new THREE.TextureLoader().load('https://aomphatch.github.io/comgraphproj/rocky_terrain_02_diff_1k.jpg', t => {
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
        });

        // ‡πÉ‡∏ä‡πâ BoxGeometry ‡πÅ‡∏ó‡∏ô PlaneGeometry ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤
        const floor = new THREE.Mesh(
        new THREE.BoxGeometry(18, 0.5, 16), // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤ 0.5
        new THREE.MeshStandardMaterial({ map: floorTex })
        );

        // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏°‡∏∏‡∏ô ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ Box ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏•‡πâ‡∏ß
        floor.position.y = -0.25; // ‡πÉ‡∏´‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏¥‡∏° (‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤)
        floor.receiveShadow = true;
        scene.add(floor);

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
        
    </script>
</body>

</html>
